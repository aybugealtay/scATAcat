<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scATAcat.helper_functions &mdash; scATAcat</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=92fd9be5" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=d45e8c67"></script>
        <script src="../../_static/doctools.js?v=888ff710"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            scATAcat Documentation
              <img src="../../_static/logo_white.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../scATAcat.html">scATAcat package</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorial/tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../citation.html">Citation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contact.html">Contact</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">scATAcat Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">scATAcat.helper_functions</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scATAcat.helper_functions</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">anndata</span>
<span class="kn">import</span> <span class="nn">scipy.sparse</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scanpy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">logging</span> <span class="k">as</span> <span class="nn">logg</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">plot_functions</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1234</span><span class="p">)</span>
<div class="viewcode-block" id="add_binary_layer">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.add_binary_layer">[docs]</a>
<span class="k">def</span> <span class="nf">add_binary_layer</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">binary_layer_key</span><span class="o">=</span><span class="s2">&quot;binary&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert the count matrix associated with the AnnData object to binary and adds it as a new layer.</span>

<span class="sd">    This function converts the count matrix in the AnnData object to binary, where non-zero values are set to 1.</span>
<span class="sd">    The resulting binary matrix is added as a new layer in the AnnData object using the specified key.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the sc count matrix.</span>
<span class="sd">    - binary_layer_key (str, optional): The key for the binary layer to be added. Default is &quot;binary&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with the binary layer added.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;binary&#39;</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="n">binary_matrix</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="n">binary_matrix</span><span class="p">[</span><span class="n">binary_matrix</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;binary&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">binary_matrix</span>
    <span class="k">return</span> <span class="n">adata</span></div>



<div class="viewcode-block" id="preproces_sc_matrix">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.preproces_sc_matrix">[docs]</a>
<span class="k">def</span> <span class="nf">preproces_sc_matrix</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span><span class="n">cell_cutoff</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">cell_cutoff_max</span><span class="o">=</span><span class="mi">80000</span><span class="p">,</span> <span class="n">feature_cutoff</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">remove_chrY</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">var_key</span> <span class="o">=</span> <span class="s1">&#39;cCREs&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Preprocess a sc count matrix in AnnData format.</span>
<span class="sd">    </span>
<span class="sd">    This function preprocesses a single-cell count matrix in AnnData format by applying the following steps:</span>
<span class="sd">    1. Filters cells based on the number of features per cell using the specified cutoffs.</span>
<span class="sd">    2. Filters features based on the number of cells per feature using the specified cutoff.</span>
<span class="sd">    3. Optionally removes features associated with chromosome Y.</span>
<span class="sd">    </span>
<span class="sd">    If copy is True, a new AnnData object with the preprocessed data is returned, leaving the original AnnData object unchanged.</span>
<span class="sd">    If copy is False, the original AnnData object is modified in place, and the preprocessed AnnData object is returned.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the sc count matrix.</span>
<span class="sd">    - cell_cutoff (int, optional): Minimum number of features required per cell. Default is 1000.</span>
<span class="sd">    - cell_cutoff_max (int, optional): Maximum number of features allowed per cell. Default is 80000.</span>
<span class="sd">    - feature_cutoff (int, optional): Minimum number of cells required per feature. Default is 3.</span>
<span class="sd">    - remove_chrY (bool, optional): Whether to remove features associated with chromosome Y. Default is True.</span>
<span class="sd">    - var_key (str, optional): Key for accessing feature information in AnnData.var. Default is &#39;cCREs&#39;.</span>
<span class="sd">    - copy (bool, optional): If True, a copy of the AnnData object is returned; if False, the original AnnData object is modified. Default is False.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The preprocessed AnnData object.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span>  <span class="s1">&#39;num_cell_per_feature&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">varm_keys</span><span class="p">()</span> <span class="ow">and</span> <span class="s1">&#39;num_feature_per_cell&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs_keys</span><span class="p">():</span>
        <span class="n">cell_feature_statistics</span><span class="p">(</span><span class="n">adata</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">copy</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;num_feature_per_cell&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cell_cutoff</span><span class="p">]</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;num_feature_per_cell&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell_cutoff_max</span><span class="p">]</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span><span class="n">adata</span><span class="o">.</span><span class="n">varm</span><span class="p">[</span><span class="s1">&#39;num_cell_per_feature&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">feature_cutoff</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">remove_chrY</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">filtered_chrY</span><span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">var_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;chrY&quot;</span><span class="p">)]</span>
            <span class="n">adata</span><span class="o">=</span><span class="n">adata</span><span class="p">[:,</span><span class="n">filtered_chrY</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">adata</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata2</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;num_feature_per_cell&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cell_cutoff</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">adata2</span> <span class="o">=</span> <span class="n">adata2</span><span class="p">[</span><span class="n">adata2</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;num_feature_per_cell&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cell_cutoff_max</span><span class="p">]</span>
        <span class="n">adata2</span> <span class="o">=</span> <span class="n">adata2</span><span class="p">[:,</span><span class="n">adata2</span><span class="o">.</span><span class="n">varm</span><span class="p">[</span><span class="s1">&#39;num_cell_per_feature&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">feature_cutoff</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">remove_chrY</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
            <span class="n">filtered_chrY</span><span class="o">=</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">adata2</span><span class="o">.</span><span class="n">var_names</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">a</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;chrY&quot;</span><span class="p">)]</span>
            <span class="n">adata2</span><span class="o">=</span><span class="n">adata2</span><span class="p">[:,</span><span class="n">filtered_chrY</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">adata2</span></div>

    

<div class="viewcode-block" id="overlap_vars">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.overlap_vars">[docs]</a>
<span class="k">def</span> <span class="nf">overlap_vars</span><span class="p">(</span><span class="n">adata1</span><span class="p">,</span> <span class="n">adata2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generic function to get shared variables between two AnnData objects.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata1 (AnnData): An AnnData object containing the sc count matrix.</span>
<span class="sd">    - adata2 (AnnData): An AnnData object containing the sc count matrix.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - List: List of shared variables. </span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">common_vars</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">adata1</span><span class="o">.</span><span class="n">var_names</span><span class="p">))</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">adata2</span><span class="o">.</span><span class="n">var_names</span><span class="p">))))</span>
    <span class="k">return</span> <span class="n">common_vars</span></div>


<span class="c1"># filter adata by var or obs list</span>

<div class="viewcode-block" id="subset_adata_vars">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.subset_adata_vars">[docs]</a>
<span class="k">def</span> <span class="nf">subset_adata_vars</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">vars_list</span><span class="p">,</span> <span class="n">copy_</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Subset the variables (features) of an AnnData object based on a specified list.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the sc count matrix.</span>
<span class="sd">    - vars_list (list): A list of variable names (features) to retain in the subset.</span>
<span class="sd">    - copy_ (bool, optional): If True, a copy of the AnnData object is returned; if False, the original AnnData object is modified. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with a subset of variables.</span>

<span class="sd">    This function subsets the variables (features) of the AnnData object based on the provided list.</span>
<span class="sd">    The resulting AnnData object includes only the variables specified in the `vars_list`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the sc single-cell count matrix.</span>
<span class="sd">    - vars_list (list): A list of variable names (features) to retain in the subset.</span>
<span class="sd">    - copy_ (bool, optional): If True, a copy of the AnnData object is returned; if False, the original AnnData object is modified. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with a subset of variables.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">copy_</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vars_list</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">adata</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata2</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[:,</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">vars_list</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">adata2</span></div>

        
<div class="viewcode-block" id="subset_adata_obs">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.subset_adata_obs">[docs]</a>
<span class="k">def</span> <span class="nf">subset_adata_obs</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">obs_list</span><span class="p">,</span> <span class="n">copy_</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Subset the observations (cells) of an AnnData object based on a specified list.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the single-cell count matrix.</span>
<span class="sd">    - vars_list (list): A list of observations names (cells) to retain in the subset.</span>
<span class="sd">    - copy_ (bool, optional): If True, a copy of the AnnData object is returned; if False, the original AnnData object is modified. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with a subset of variables.</span>

<span class="sd">    This function subsets the observations (cells) of the AnnData object based on the provided list.</span>
<span class="sd">    The resulting AnnData object includes only the variables specified in the `vars_list`.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the single-cell count matrix.</span>
<span class="sd">    - vars_list (list): A list of observations names (cells) to retain in the subset.</span>
<span class="sd">    - copy_ (bool, optional): If True, a copy of the AnnData object is returned; if False, the original AnnData object is modified. Default is True.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with a subset of observations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">copy_</span><span class="o">==</span><span class="kc">False</span><span class="p">:</span>
        <span class="n">adata</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">obs_list</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">adata</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">adata2</span> <span class="o">=</span> <span class="n">adata</span><span class="p">[</span><span class="nb">sorted</span><span class="p">(</span><span class="n">obs_list</span><span class="p">)]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">adata2</span></div>



<div class="viewcode-block" id="apply_TFIDF_sparse">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.apply_TFIDF_sparse">[docs]</a>
<span class="k">def</span> <span class="nf">apply_TFIDF_sparse</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">binary_layer_key</span><span class="o">=</span><span class="s1">&#39;binary&#39;</span><span class="p">,</span> <span class="n">TFIDF_key</span><span class="o">=</span><span class="s1">&#39;TF_logIDF&#39;</span> <span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Apply Term Frequency - Inverse Document Frequency TF-log(IDF) normalization to the binary layer of the AnnData object.</span>
<span class="sd">    If the binary layer is not present, it calculates and adds the binary layer using the specified key.</span>
<span class="sd">    Additionally, if cell and feature statistics are not available, it calculates them using the binary layer.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData):  An AnnData object containing the sc count matrix.</span>
<span class="sd">    - binary_layer_key (str): The key for accessing the binary layer. Default is &quot;binary&quot;.</span>
<span class="sd">    - TFIDF_key (str): The key for the TFIDF normalized matrix layer to be added. Default is &quot;TF_logIDF&quot;.</span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with the TF-log(IDF) normalized layer added.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">binary_layer_key</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
        <span class="n">add_binary_layer</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">binary_layer_key</span><span class="o">=</span><span class="n">binary_layer_key</span><span class="p">)</span>
    <span class="k">if</span>  <span class="s1">&#39;num_cell_per_feature&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">varm_keys</span><span class="p">()</span> <span class="ow">and</span> <span class="s1">&#39;num_feature_per_cell&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">adata</span><span class="o">.</span><span class="n">obs_keys</span><span class="p">():</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;calculating cell and feature statistics&quot;</span><span class="p">)</span>
        <span class="n">cell_feature_statistics</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">binary_layer_key</span> <span class="o">=</span><span class="n">binary_layer_key</span><span class="p">)</span>
    
    <span class="n">TF</span><span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">binary_layer_key</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="o">*</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;num_feature_per_cell&#39;</span><span class="p">])</span>
    <span class="n">IDF</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">n_vars</span> <span class="o">/</span> <span class="n">adata</span><span class="o">.</span><span class="n">varm</span><span class="p">[</span><span class="s1">&#39;num_cell_per_feature&#39;</span><span class="p">]</span>
    <span class="n">TF_logIDF</span> <span class="o">=</span> <span class="n">TF</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">IDF</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">IDF</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)))</span>
    <span class="n">TF_logIDF_t</span><span class="o">=</span> <span class="n">TF_logIDF</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">TFIDF_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">TF_logIDF_t</span>
    <span class="k">return</span> <span class="n">adata</span></div>


<span class="c1">#########</span>
<span class="c1"># wrapper function for scanpy&#39;s pca</span>

<div class="viewcode-block" id="apply_PCA">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.apply_PCA">[docs]</a>
<span class="k">def</span> <span class="nf">apply_PCA</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">layer_key</span> <span class="o">=</span> <span class="s2">&quot;TF_logIDF&quot;</span><span class="p">,</span> <span class="n">svd_solver</span> <span class="o">=</span> <span class="s1">&#39;arpack&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper around scanpy.tl.pca to enable applying scanpy.tl.pca function to a specified layer</span>
<span class="sd">    </span>
<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData):  An AnnData object containing the sc count matrix.</span>
<span class="sd">    - layer_key: The key for accessing the layer to which PCA is applied. Default is &quot;TF_logIDF&quot;. </span>
<span class="sd">    </span>
<span class="sd">    see scanpy documentaion for details: https://scanpy.readthedocs.io/en/latest/generated/scanpy.tl.pca.html#scanpy-tl-pca</span>
<span class="sd">    adds the _pca, _components, explained_variance_ratio_, explained_variance_  to adata object</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with the TF-log(IDF) normalized layer added.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">pca__</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">tl</span><span class="o">.</span><span class="n">pca</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">layer_key</span><span class="p">],</span> <span class="n">svd_solver</span><span class="o">=</span> <span class="n">svd_solver</span><span class="p">,</span> <span class="n">return_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">random_state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># define ins annotations for pca</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;pca&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># X_pca</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">obsm</span><span class="p">[</span><span class="s1">&#39;X_pca&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pca__</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># components_</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">varm</span><span class="p">[</span><span class="s1">&#39;PCs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pca__</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="c1"># explained_variance_</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;pca&#39;</span><span class="p">][</span><span class="s1">&#39;variance&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pca__</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> 
    <span class="c1"># explained_variance_ratio_</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">uns</span><span class="p">[</span><span class="s1">&#39;pca&#39;</span><span class="p">][</span><span class="s1">&#39;variance_ratio&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pca__</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> 
    
    <span class="k">return</span> <span class="n">adata</span></div>



<span class="c1">#################################################</span>
<span class="c1"># normalization </span>
<div class="viewcode-block" id="preprocessing_libsize_norm_log2">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.preprocessing_libsize_norm_log2">[docs]</a>
<span class="k">def</span> <span class="nf">preprocessing_libsize_norm_log2</span><span class="p">(</span><span class="n">adata</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform libray-size normalization &amp; log2 transformation on the Anndata object.</span>
<span class="sd">    Normalized and log2 transformed matrix is added as a layer with keyword &quot;libsize_norm_log2&quot;. </span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the sc count matrix.</span>

<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with the libsize_norm_log2 normalized layer added.</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">libsize</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">countdata_matrix</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
    <span class="n">adata_X_libsize_normalized_log2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">((</span><span class="n">countdata_matrix</span><span class="o">/</span><span class="n">libsize</span> <span class="o">*</span><span class="mi">1000000</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="s2">&quot;libsize_norm_log2&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">adata_X_libsize_normalized_log2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">adata</span></div>



<span class="c1"># this function is copied from scanpy </span>
<span class="k">def</span> <span class="nf">_get_mean_var</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
        <span class="n">mean</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">sparse_mean_variance_axis</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">mean_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">mean_sq</span> <span class="o">-</span> <span class="n">mean</span><span class="o">**</span><span class="mi">2</span>
    <span class="c1"># enforce R convention (unbiased estimator) for variance</span>
    <span class="n">var</span> <span class="o">*=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">mean</span><span class="p">,</span> <span class="n">var</span>

<span class="c1"># this function is copied from scanpy </span>

<div class="viewcode-block" id="sparse_mean_variance_axis">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.sparse_mean_variance_axis">[docs]</a>
<span class="k">def</span> <span class="nf">sparse_mean_variance_axis</span><span class="p">(</span><span class="n">mtx</span><span class="p">:</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">spmatrix</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This code and internal functions are based on sklearns</span>
<span class="sd">    `sparsefuncs.mean_variance_axis`.</span>

<span class="sd">    Modifications:</span>
<span class="sd">    * allow deciding on the output type, which can increase accuracy when calculating the mean and variance of 32bit floats.</span>
<span class="sd">    * This doesn&#39;t currently implement support for null values, but could.</span>
<span class="sd">    * Uses numba not cython</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">):</span>
        <span class="n">ax_minor</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">mtx</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mtx</span><span class="p">,</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csc_matrix</span><span class="p">):</span>
        <span class="n">ax_minor</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">mtx</span><span class="o">.</span><span class="n">shape</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This function only works on sparse csr and csc matrices&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="n">ax_minor</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sparse_mean_var_major_axis</span><span class="p">(</span>
            <span class="n">mtx</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mtx</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="n">mtx</span><span class="o">.</span><span class="n">indptr</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">sparse_mean_var_minor_axis</span><span class="p">(</span><span class="n">mtx</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">mtx</span><span class="o">.</span><span class="n">indices</span><span class="p">,</span> <span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></div>



<div class="viewcode-block" id="preprocessing_standardization">
<a class="viewcode-back" href="../../scATAcat.html#scATAcat.helper_functions.preprocessing_standardization">[docs]</a>
<span class="k">def</span> <span class="nf">preprocessing_standardization</span><span class="p">(</span><span class="n">adata</span><span class="p">,</span> <span class="n">input_layer_key</span><span class="o">=</span><span class="s2">&quot;libsize_norm_log2&quot;</span><span class="p">,</span> <span class="n">output_layer_key</span> <span class="o">=</span> <span class="s2">&quot;libsize_norm_log2_std&quot;</span><span class="p">,</span> <span class="n">std_key</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="n">mean_key</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std_</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">mean_</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">zero_center</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Perform z-normalization at the feature level. If the standard deviation (std) and mean are already included in the AnnData (adata), the function applies normalization directly. In the absence of these variables, it calculates and adds the standard deviation and mean to the AnnData using the specified layer key (layer_key). Subsequently, it performs z-normalization.</span>

<span class="sd">    Additionally, if alternative std_ and mean_ matrices/arrays are provided, these values are utilized for the calculations instead of assuming zero mean and unit variance.</span>

<span class="sd">    Parameters:</span>
<span class="sd">    - adata (AnnData): An AnnData object containing the sc count matrix.</span>
<span class="sd">    - input_layer_key (str): The key for accessing the layer to which standardization is applied. Default is &quot;libsize_norm_log2&quot;. </span>
<span class="sd">    - output_layer_key (str): The key for the standardized layer to be added. Default is &quot;libsize_norm_log2_std&quot;.</span>
<span class="sd">    - std_key (str): The key for the standard deviation to be added. If None, &quot;feature_std&quot; is added as key.</span>
<span class="sd">    - mean_key (str): The key for the mean to be added. If None, &quot;feature_std&quot; is added as key.  </span>
<span class="sd">    - std_ (numpy array): The key for accessing the standard deviation. If specified, it is utilized for the  z-score calculations instead of assuming zero mean and unit variance. Default is None. </span>
<span class="sd">    - mean_ (numpy array): The key for accessing the mean. If specified, it is utilized for the  z-score calculations instead of assuming zero mean and unit variance. Default is None. </span>

<span class="sd">    Returns:</span>
<span class="sd">    - AnnData: The AnnData object with the libsize_norm_log2_std standardized layer added.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">try</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">std_key</span><span class="p">])</span>

    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span><span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span> <span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;adding std with default keywords&quot;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">mean_key</span><span class="p">])</span>

    <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">)</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;adding mean with default keywords&quot;</span><span class="p">)</span>
              
    <span class="k">if</span> <span class="n">std_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">std_key</span> <span class="o">=</span> <span class="s2">&quot;feature_std&quot;</span>
    <span class="k">if</span> <span class="n">mean_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">mean_key</span> <span class="o">=</span> <span class="s2">&quot;feature_mean&quot;</span>
    <span class="k">if</span> <span class="n">input_layer_key</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">output_layer_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_layer_key</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">input_layer_key</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_std&quot;</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">logg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;... as scaling leads to float results, integer &#39;</span>
                <span class="s1">&#39;input is cast to float, returning copy.&#39;</span><span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">mean</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_get_mean_var</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">])</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">std</span><span class="p">[</span><span class="n">std</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">std_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">mean_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>
       <span class="c1"># check this!! it was working better with std and mean chanign it&#39;s places 19oct23</span>
        <span class="c1"># adata.var[std_key] = mean</span>
       <span class="c1"># adata.var[mean_key] = std</span>

        <span class="k">if</span> <span class="n">zero_center</span><span class="p">:</span>
            <span class="n">scaled_X</span>  <span class="o">=</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span> <span class="o">-</span>  <span class="n">mean</span><span class="p">)</span> 
            <span class="n">scaled_X</span> <span class="o">/=</span> <span class="n">std</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;... using the user given mean and std&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">std_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mean_ or std_ is not given as an input &quot;</span>
                     <span class="s2">&quot;activating zero scaling &quot;</span><span class="p">)</span>
                <span class="n">scaled_X</span>  <span class="o">=</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span> <span class="o">-</span>  <span class="n">mean</span><span class="p">)</span> 
                <span class="n">scaled_X</span> <span class="o">/=</span> <span class="n">std</span>


            <span class="n">scaled_X</span>  <span class="o">=</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span> <span class="o">-</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean_</span><span class="p">))</span> 
            <span class="n">std_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">std_</span><span class="p">)</span>
            <span class="n">std_</span><span class="p">[</span><span class="n">std_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">scaled_X</span> <span class="o">/=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">std_</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">output_layer_key</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_layer_key</span> <span class="o">=</span> <span class="s2">&quot;std_matrix&quot;</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">logg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;... as scaling leads to float results, integer &#39;</span>
                <span class="s1">&#39;input is cast to float, returning copy.&#39;</span><span class="p">)</span>
            <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

        <span class="n">mean</span><span class="p">,</span> <span class="n">var</span> <span class="o">=</span> <span class="n">_get_mean_var</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="n">std</span><span class="p">[</span><span class="n">std</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">std_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">mean</span>
        <span class="n">adata</span><span class="o">.</span><span class="n">var</span><span class="p">[</span><span class="n">mean_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span>

        <span class="k">if</span> <span class="n">zero_center</span><span class="p">:</span>
            <span class="n">scaled_X</span>  <span class="o">=</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span>  <span class="n">mean</span><span class="p">)</span> 
            <span class="n">scaled_X</span> <span class="o">/=</span> <span class="n">std</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logg</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;... using the user given mean and std&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mean_</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">std_</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;mean_ or std_ is not given as an input &quot;</span>
                     <span class="s2">&quot;activating zero scaling &quot;</span><span class="p">)</span>
                <span class="n">scaled_X</span>  <span class="o">=</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">X</span> <span class="o">-</span>  <span class="n">mean</span><span class="p">)</span> 
                <span class="n">scaled_X</span> <span class="o">/=</span> <span class="n">std</span>

            <span class="n">scaled_X</span>  <span class="o">=</span> <span class="p">(</span><span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">input_layer_key</span><span class="p">]</span> <span class="o">-</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mean_</span><span class="p">))</span>
            <span class="n">std_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">std_</span><span class="p">)</span>
            <span class="n">std_</span><span class="p">[</span><span class="n">std_</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">scaled_X</span> <span class="o">/=</span>  <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">std_</span><span class="p">)</span>
        
    <span class="n">adata</span><span class="o">.</span><span class="n">layers</span><span class="p">[</span><span class="n">output_layer_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">scaled_X</span>
    <span class="k">return</span> <span class="n">adata</span>    </div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Aybuge Altay.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>